#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <signal.h>

static int current_conn = -1;

void handle_connection(int sockfd) {
    struct sockaddr_in client_addr;
    socklen_t addrlen = sizeof(client_addr);
    int connfd = accept(sockfd, (struct sockaddr *)&client_addr, &addrlen);
    if (connfd < 0) {
        perror("Error accepting connection");
        return;
    }

    if (current_conn == -1) {
        current_conn = connfd;
        std::cout << "Accepted new connection" << std::endl;
    } else {
        close(connfd);
        std::cout << "Rejected new connection" << std::endl;
    }
}

void handle_data() {
    // handle data received from current_conn
    // For simplicity, here we just print the amount of data received
    int data_count = 0;
    // Code to read data from current_conn and update data_count
    std::cout << "Received " << data_count << " bytes of data" << std::endl;
}

void handle_signal(int signal) {
    std::cout << "Received signal " << signal << std::endl;
    // Do something in response to the signal
}

int main() {
    // Create a TCP socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("Error creating socket");
        return 1;
    }

    // Bind the socket to a port
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(12345); // Port number
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Error binding socket");
        return 1;
    }

    // Listen for incoming connections
    if (listen(sockfd, 5) < 0) {
        perror("Error listening on socket");
        return 1;
    }

    // Set up signal handler
    signal(SIGHUP, handle_signal);

    while (1) {
        // Set up the file descriptors for select
        fd_set read_set;
        FD_ZERO(&read_set);
        FD_SET(sockfd, &read_set);
        if (current_conn != -1) {
            FD_SET(current_conn, &read_set);
        }

        // Wait for any activity on the socket or current_conn
        if (pselect(FD_SETSIZE, &read_set, NULL, NULL, NULL, NULL) < 0) {
            perror("Error in pselect");
            return 1;
        }

        // Accept new connections
        if (FD_ISSET(sockfd, &read_set)) {
            handle_connection(sockfd);
        }

        // Handle data on current connection
        if (current_conn != -1 && FD_ISSET(current_conn, &read_set)) {
            handle_data();
        }
    }

    return 0;
}
